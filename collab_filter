{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "31dffcc2-f8b3-44e0-ab5c-8ae9a7956e63",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import re\n",
    "from collections import defaultdict\n",
    "from math import log, sqrt\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from wordcloud import WordCloud\n",
    "\n",
    "# load dataset\n",
    "perfumes = pd.read_csv(\"data/full_perfumes.csv\")\n",
    "perfumes = perfumes.dropna(subset=['notes', 'mainaccord1'])\n",
    "\n",
    "# tokenize and clean\n",
    "def clean_token_string(text):\n",
    "    text = re.sub(r'\\b(and)\\b', '', text.lower())\n",
    "    text = re.sub(r'-+', '-', text)\n",
    "    text = re.sub(r'-$', '', text)\n",
    "    text = re.sub(r'^-', '', text)\n",
    "    return text.strip()\n",
    "\n",
    "def tokenize(row):\n",
    "    accords = [clean_token_string(row.get(f'mainaccord{i}', '')) for i in range(1, 5) if pd.notna(row.get(f'mainaccord{i}'))]\n",
    "    notes = [clean_token_string(note) for note in row['notes'].split(',') if note.strip()]\n",
    "    return accords + notes  \n",
    "    \n",
    "perfumes['tokens'] = perfumes.apply(tokenize, axis=1)\n",
    "\n",
    "# vocabulary and idf\n",
    "vocab = defaultdict(int)\n",
    "for tokens in perfumes['tokens']:\n",
    "    for token in set(tokens):\n",
    "        vocab[token] += 1\n",
    "\n",
    "total_docs = len(perfumes)\n",
    "idf = {word: log(total_docs / perfume_count) for word, perfume_count in vocab.items()}\n",
    "\n",
    "# TF-IDF vectors\n",
    "def compute_tfidf(tokens, idf):\n",
    "    tf = defaultdict(int)\n",
    "    for token in tokens:\n",
    "        tf[token] += 1\n",
    "    max_tf = max(tf.values())\n",
    "    return {token: (count / max_tf) * idf[token] for token, count in tf.items() if token in idf}\n",
    "\n",
    "perfumes['tfidf'] = perfumes['tokens'].apply(lambda tokens: compute_tfidf(tokens, idf))\n",
    "\n",
    "# cosine similarity function\n",
    "def cosine_similarity(vec1, vec2):\n",
    "    common = set(vec1.keys()) & set(vec2.keys())\n",
    "    dot_product = sum(vec1[t] * vec2[t] for t in common)\n",
    "    norm1 = sqrt(sum(v**2 for v in vec1.values()))\n",
    "    norm2 = sqrt(sum(v**2 for v in vec2.values()))\n",
    "    return dot_product / (norm1 * norm2) if norm1 and norm2 else 0.0\n",
    "\n",
    "# indexing\n",
    "perfumes['perfume_lower'] = perfumes['perfume'].str.lower()\n",
    "perfumes['brand_lower'] = perfumes['brand'].str.lower()\n",
    "perfumes['perfume_brand_key'] = perfumes['perfume_lower'] + \"|\" + perfumes['brand_lower']\n",
    "indices = pd.Series(perfumes.index, index=perfumes['perfume_brand_key']).drop_duplicates()\n",
    "\n",
    "# rec function\n",
    "def get_recs(perfume_name, brand_name, top_n=5):\n",
    "    key = f\"{perfume_name.lower()}|{brand_name.lower()}\"\n",
    "    idx = indices.get(key)\n",
    "    if idx is None:\n",
    "        return None, None, None\n",
    "\n",
    "    query_vec = perfumes.loc[idx, 'tfidf']\n",
    "    query_perfume = perfumes.loc[idx, 'perfume']\n",
    "    query_brand = perfumes.loc[idx, 'brand'].strip().lower()\n",
    "\n",
    "    similarities = []\n",
    "    for i, row in perfumes.iterrows():\n",
    "        if i == idx or row['brand'].strip().lower() == query_brand:\n",
    "            continue\n",
    "        sim = cosine_similarity(query_vec, row['tfidf'])\n",
    "        similarities.append((i, sim))\n",
    "\n",
    "    similarities = sorted(similarities, key=lambda x: x[1], reverse=True)[:top_n]\n",
    "    top_indices = [i for i, _ in similarities]\n",
    "    top_perf = perfumes.loc[top_indices].copy()\n",
    "    top_perf['Similarity'] = [s for _, s in similarities]\n",
    "    return query_perfume, perfumes.loc[idx], top_perf\n",
    "\n",
    "# prompt\n",
    "def prompt_user():\n",
    "    print(\"Welcome to the Perfume Recommender!\")\n",
    "    print(\"To find similar perfumes, please follow these input tips:\")\n",
    "    print(\"- Use dashes (-) instead of spaces (e.g., 'poppy-barley')\")\n",
    "    print(\"- Brand names are case-insensitive (e.g., 'Le-Labo')\")\n",
    "    print(\"- Some perfumes like 'Chanel No 5' are written as 'Chanel-N05'\")\n",
    "    print(\"- Disregard any 'and's that appear in perfume or brand names (e.g., 'poppy-and-barley' becomes 'poppy-barley')\\n\")\n",
    "    brand_input = input(\"Enter the **brand** of the perfume: \").strip().lower()\n",
    "    perfume_input = input(\"Enter the **name** of the perfume: \").strip().lower()\n",
    "    return perfume_input, brand_input\n",
    "\n",
    "# run it all\n",
    "if __name__ == \"__main__\":\n",
    "    perfume_name, brand_name = prompt_user()\n",
    "    query_perfume, query_row, top_perf = get_recs(perfume_name, brand_name)\n",
    "\n",
    "    if top_perf is not None:\n",
    "        print(f\"\\nTop Recommendations for '{query_perfume}' by {brand_name.title()}:\\n\")\n",
    "        top_perf['Main Accords'] = top_perf.apply(\n",
    "            lambda row: ', '.join([str(row.get(f'mainaccord{i}', '')) for i in range(1, 5) if pd.notna(row.get(f'mainaccord{i}'))]),\n",
    "            axis=1)        \n",
    "        print(top_perf[['perfume', 'brand', 'Similarity', 'rating_value', 'gender', 'Main Accords', 'notes']].to_markdown(index=False))\n",
    "\n",
    "        # heatmap\n",
    "        vectors = [query_row['tfidf']] + top_perf['tfidf'].tolist()\n",
    "        labels = [query_perfume] + top_perf['perfume'].tolist()\n",
    "        sim_matrix = np.array([[cosine_similarity(v1, v2) for v2 in vectors] for v1 in vectors])\n",
    "\n",
    "        plt.figure(figsize=(8, 6))\n",
    "        sns.heatmap(sim_matrix, xticklabels=labels, yticklabels=labels, annot=True, cmap='YlGnBu')\n",
    "        plt.title(\"Cosine Similarity Between Query and Recommendations\")\n",
    "        plt.xticks(rotation=45, ha='right')\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "\n",
    "        # word cloud\n",
    "        all_notes = ', '.join(top_perf['notes'].tolist())\n",
    "        wordcloud = WordCloud(width=800, height=400, background_color='white').generate(all_notes)\n",
    "\n",
    "        plt.figure(figsize=(10, 5))\n",
    "        plt.imshow(wordcloud, interpolation='bilinear')\n",
    "        plt.axis('off')\n",
    "        plt.title(\"Common Notes in Top Recommendations\")\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "    else:\n",
    "        print(\"\\n No perfume found. Please check spelling and try again.\")\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.19"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
